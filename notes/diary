23/07/21
wtfff i swear. sshit confusing. so CHAR,,, is an integer. and this: 'a' is just a ascii assignation (decimal).
an char has the smallest rank (1) because it just accepts such few numbers. you use it beacuse its small range means
it doesnt need as much space. you could just use int, but char is better bc its jst one byte. while int,, has 4.
bc int can carry a lot of numbers. that's good! just 4 bytes for so manyy nuumbers! crazy.
okay. now we need to find out wtf is up with va_arg.

bool = ffukin 1 bit. cuz it's literally just 0 and 1.
there's no signed or unsigned, for what lmao
i should use this bad bitch, she's cool!

char = 1 byte = 8 bits
normal / signed: -128 - 127 (all the ascii characters + minuszahlen)
unsigned: 0 - 255

short = 2 bytes = 16 bits
normal / signed: -32768 - 32767
unsigned: 0 - 65535

int = 4 bytes = 32 bits
normal / signed: -2147483648 - 2147483647
unsigned: 0 - 4294967295

long (ðŸ–•) = 4 bytes = 32 bits (usually)
same as int

long long = 8 bytes = 64 bits
normal / signed: -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807
unsigned: 0 - 18,446,744,073,709,551,615

CASTING POINTERS:
if you do this: ptr++
or use the brackets like: ptr[0], ptr[1], ptr[2], ...

that's where there's a difference between certain types of pointers. int ptr will move 4 bytes, char ptr moves 1
(with brackets per number). A BOOL ARRAY OF 8 IS JUST A BYTE. lol. you could simulate a compuer like that huh.
but that's super unnecessary. we already have a computer and the language is the tool to access it, why would
we decrunstruct the tool and make it more complicated, when it's supposed to become less complicated.
so whatever. pointers always have the same size (in the same system). no matter what kind of pointer.
it's just interesting to think abou different kinds of pointers bc like a boolean ptr will move like 1 fuckin bit.
imagine using bool typecasting. not sure if they'd accept that. whatever. long long would move 8 fukcin bytes.
thta's a lot. cool.
